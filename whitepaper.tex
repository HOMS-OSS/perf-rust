\documentclass{article}
\usepackage[utf8]{inputenc}

\title{\texttt{perf} in Rust}
\author{Timothy Maloney}
\date{Summer 2021}

\begin{document}

\maketitle
\section*{Abstract}
This paper is a living document that provides a high-level vision for the performance analysis tool \texttt{ruperf}.
We begin by describing performance analysis in the context of software development, and discussing key features of other 
performance analysis tools such as \texttt{perf}, Vtune, and flamegraph. We then provide an overview of how \texttt{ruperf} works
and the capabiliies it provides. Lastly, we explain what \texttt{ruperf} will look like moving forward, and our goals for making it 
fit into the current scope of performance analysis tools.
\pagebreak
\section{Introduction to Performance Analysis}
Analyzing performance is a key element of any serious endeavor. In the context of today's modern world, it is necessary
that the software managing our lives performs at a high level; making sure that it does can only be done by going underneath the hood 
and identifying areas where performance may be improved. Things like hardware instructions, cache-misses,
and context switches are mandatory considerations when analyzing software performance.
\\\\
Fortunately, there are many tools for performance analysis at a programmer's disposal. These tools can be used to provide a
thorough background of what is going on at the lowest levels of your machine and software. There are many different tools to use, all with
unique purposes and features. We provide a brief description of a few well-known tools in the following subsection.
\subsection{\texttt{perf}}
Per the wiki, "\texttt{perf} is a profiler tool for linux-based systems that abstracts away CPU hardware differences in Linux performance measurements and presents a simple command-line interface." There are numerous \texttt{perf} sub-commands to analyze performance and trace data. \texttt{perf} is very similar to \texttt{git}; There is a generic tool \texttt{perf} that
implements a set of commands.
\section{Performance Analysis Tools}
\subsection{VTune}
VTune is a performance analysis tool provided by Intel. It identifies
time-intensive functions, processor-heavy code, time spent on I/O,
hardware-related issues such as cache misses and branch misprediction, among
other profiling features. VTune is compatible with Linux, Windows, and macOS
environments. VTune is compatible only with Intel chips. Also, it is not an
open-source tool unlike the other tools discussed in this whitepaper so
implementation details are not available for discussion.
\subsection{Gprof}
Gprof is a performance analysis tool for Unix applications which uses
instrumentation and sampling to track code that takes most execution time in a
program and determine program hot spots . Gprof determines the source of a
function call each time it is made, counts how many times it is called, and
watces the
running program to keep a histogram of the program to see where the program
counter is. Gprof does not indicate whether I/O or swapping slow a program so it
may report short running time for programs that are in fact long running. Gprof
is useful in identifying program hot spots.
\subsection{DHAT: dynamic heap analysis tool}
Part of Valgrind, DHAT examines programs use of heap allocation. It tracks
allocated blocks, inspects memory access and returns a variety of information
about each block's use. It identifies process-lifetime leaks, excessive
turnover, short-lived blocks, unused or underused allocations and inefficiently
laid-out blocks. It measures program progress by counting instructions.
According to the \underline{Rust Performance Book}, DHAT is compatible with
tracking the performance of Rust programs. The work DHAT does is a different way
of looking at performance profiling than with \texttt{perf}, however it is
included as a tool compatible with performance profiling Rust programs as a
matter of interest.
\subsection{flamegraph}
FlameGraph is a tool pioneered and released by Brendan Gregg in December 2011.
It's a visual representation of profiled software to help make it easier to
understand where a program is spending its time. X-axis of a graph shows the
stack profile in alphabetic order and the y-axis shows stack depth. FlameGraph
can be used with any profiling tool that creates a stack trace, including
\texttt{perf}. Crates.io includes an export of FlameGraph for the Rust community.
\section{Events and Environments}
Events in this context are simply asynchronous actions that are external to the currently executing environment. The executing environment can be specified on a per-thread, per-process, per-cpu, or system-wide basis; e.g. in per-thread mode, the performance counters are only measured during execution of a designated thread. 
\\\\
\texttt{perf} has a list of measurable events. There are effectively four types of events:
\begin{itemize}
    \item \textbf{Software Events}
    \item \textbf{Hardware PMU Events}
    \item \textbf{Hardware Cache Events}
    \item \textbf{Tracepoint Events}
\end{itemize}
\subsection{Event Selection}
It is important to consider the events to be measured and distinguish their types. The scope of events we measure and their types are described via the following table:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Event} & \textbf{Type}  \\
        \hline
         cpu-cycles & Hardware\\
         instructions & Hardware\\
         L1-dcache-loads & Hardware cache\\
         L1-dcache-load-misses & Hardware cache\\
         context-switches & Software\\
         page faults & Software\\
         cpu-clock & Software\\
         task-clock & Software\\
    \hline
    \end{tabular}
\end{center}
\pagebreak
\subsection{Environment Selection}
%% per-thread/per-process/per-cpu %%
\section{QEMU Virtual Machine}
The decision to use QEMU as a virtual machine is because performance counters are hardware-specific, and everyone in our group uses a different machine. The machine used in this project is the q35 chip, which was specified by using the \texttt{-machine type=q35} option when starting a QEMU virtual machine. %% TODO: SPECIFY MACHINE %% 
\pagebreak
\section{\texttt{perf stat}}
\subsection{Introduction}
A very useful \verb|perf| command is \verb|stat|. More clearly, \texttt{perf stat <command>} executes \texttt{command} and gathers performance counter statistics associated with it. Performance counters are registers that store the counts of hardware-related activities. As an example, this command:
\\\\
\centerline{\texttt{perf stat dd if=/dev/zero of=/dev/null count=1000000}}
\\\\
has the following (partial) output:
\\\\
\texttt{..}\\
\centerline{\texttt{ 5,099 cache-misses \hspace{5mm} \# \hspace{5mm} 0.005 M/sec (scaled from 66.58\%)}}\\
\texttt{..}
\\\\
So, during the execution of \verb|dd..| there were 5,099 total cache misses, with one miss occurring every 5 milliseconds.
One or more events may be measured by using the \texttt{-e} flag and their designated name. It is important to note that by default events are measured at both user and kernel levels. This can also be modified by specifying either the \texttt{-u} flag or the \texttt{-k} flag. e.g. Only checking cache misses that occurred during command execution at the user level looks like:
\\\\
\centerline{\texttt{perf stat -e cache-misses:u dd..}}
\\\\
\subsection{Output}
\section{\texttt{perf test}}
\section{Testing}
\pagebreak
\section{References}
Eranian, Stephane, et al. “Main Page.” Perf Wiki, Kernel.org,
\\perf.wiki.kernel.org/index.php/Main\_Page.
``GNU gprof'', sourceware.org,
https://sourceware.org/binutils/docs/gprof/Implementation.html.
Nethercote, Nicholas and others.''Profiling''. \underline{The Rust Performance Book}. November 2020.
Gregg, Brendan. ``Flame Graphs''. http://www.brendangregg.com/flamegraphs.html.
\end{document}
